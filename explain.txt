3.6.5 재사용 가능한 콜백의 분리

-DI를 위한 코드 정리
 이제 필요 없어진 DataSource 인스턴스 변수는 제거한다. UserDao의 모든 메서드가 JdbcTemplate을 이용하도록
만들었으니 DataSource를 직접 사용할 일은 없다.
단지 JdbcTemplate을 생성하면서 직접 DI 해주기 위해 필요한 DataSource를 전달받아야 하니 수정자 메서드는 남겨둔다.
정리하고 나면 밑의 코드처럼 JdbcTemplate 인스턴스 변수와 DataSource 타입 수정자 메서드만 깔끔하게 남는다.

private JdbcTemplate jdbcTemplate;

public void setDataSource(DataSource dataSource) {
    this.jdbcTemplate = new JdbcTemplate(dataSource);
}

- 중복 제거
 get()과 getAll()을 보면 사용한 RowMapper의 내용이 똑같다는 사실을 알 수 있다. 사용되는 상황은 다르지만
ResultSet 로우 하나를 User 오브젝트 하나로 변환해주는 동일한 기능을 가진 콜백이다.
UserDao에 앞으로 추가될 기능을 예상해보면 RowMapper의 사용이 여기서 끝날 것 같지는 않다.
다양한 조건으로 사용자를 조회하는 검색 기능이 추가될 것이다. 이름으로 검색할 수도 있고, 로그인을 위해
아이디와 비밀번호로 검색할 수도 있다.
이런 메서드에서 매번 동일한 RowMapper를 사용하게 될 것이다. 또한 User의 필드가 추가되거나 수정되는 경우도
충분히 예상할 수 있다.
User 테이블의 필드를 추가하고 수정하면, 매핑작업을 해주는 RowMapper 콜백의 코드도 함께 수정해야 한다.
두 개 이상의 RowMapper가 있는데 모두 정확하게 수정해주지 않으면 문제가 발생한다.
따라서 User용 RowMapper 콜백을 메서드에서 분리해 중복을 없애고 재사용되게 만들어야 한다.
먼저 매번 RowMapper 오브젝트를 새로 만들어야 할지 생각해보자. RowMapper 콜백 오브젝트에는 상태정보가 없다.
따라서 하나의 콜백 오브젝트를 멀티 스레드에서 동시에 사용해도 문제가 되지 않는다.
RowMapper 콜백은 하나만 만들어서 공유한다.

- 템플릿/콜백 패턴과 UserDao
 UserDao에는 User 정보를 DB에 넣거나 가져오거나 조작하는 방법에 대한 핵심적인 로직만 담겨 있다.
User라는 자바오브젝트와 USER 테이블 사이에 어떻게 정보를 주고 받을지, DB와 커뮤니케이션하기 위한
SQL 문장이 어떤 것인지에 대한 최적화된 코드를 갖고 있다. 만약 사용할 테이블과 필드정보가 바뀌면
UserDao의 거의 모든 코드가 함께 바뀐다. 따라서 응집도가 높다고 볼 수 있다.

 반면에 JDBC API를 사용하는 방식, 예외처리, 리소스의 반납, DB 연결을 어떻게 가져올지에 관한 책임과 관심은
모두 JdbcTemplate에게 있다. 따라서 변경이 일어난다고 해도 UserDao 코드에는 아무런 영향을 주지 않는다.
그런 면에서 책임이 다른 코드와는 낮은 결합도를 유지하고 있다.
다만 JdbcTemplate이라는 템플릿 클래스를 직접 이용한다는 면에서 특정 템플릿/콜백 구현에 대한 강한 결합을
갖고있다. JdbcTemplate이 스프링에서 JDBC를 이용 DAO를 만드는 데 사용되는 사실상 표준기술이고,
JDBC 대신 다른 데이터 액세스 기술을 사용하지 않는 한 바뀔 리도 없겠지만, 그래도 더 낮은 결합도를
유지하고 싶다면 JdbcTemplate을 독립적인 빈으로 등록하고 JdbcTemplate이 구현하고 있는 JdbcOperations 인터페이스를
통해 DI 받아 사용하도록 만들어도 된다.
